'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};
var RADIO_INPUT = 'radio';
var UNDEFINED = 'undefined';
var EVENTS = {
    BLUR: 'blur',
    CHANGE: 'change',
    INPUT: 'input',
};
var INPUT_VALIDATION_RULES = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate',
};

function attachEventListeners(_a) {
    var field = _a.field, validateAndStateUpdate = _a.validateAndStateUpdate, isRadioOrCheckbox = _a.isRadioOrCheckbox;
    var ref = field.ref;
    if (!ref.addEventListener) {
        return;
    }
    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);
    ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);
}

var isUndefined = (function (val) { return val === undefined; });

var isNullOrUndefined = (function (value) {
    return value === null || isUndefined(value);
});

var isArray = (function (value) { return Array.isArray(value); });

var isObject = (function (value) {
    return !isNullOrUndefined(value) && !isArray(value) && typeof value === 'object';
});

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value) {
    return reIsUint.test(value) && value > -1;
}
function isKey(value) {
    if (isArray(value)) {
        return false;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);
}
var stringToPath = function (string) {
    var result = [];
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
};
function set(object, path, value) {
    var index = -1;
    var tempPath = isKey(path) ? [path] : stringToPath(path);
    var length = tempPath.length;
    var lastIndex = length - 1;
    while (++index < length) {
        var key = tempPath[index];
        var newValue = value;
        if (index !== lastIndex) {
            var objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : isIndex(tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var combineFieldValues = (function (data) {
    return Object.entries(data).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        if (!!key.match(/\[.+\]/gi) || key.indexOf('.') > 0) {
            set(previous, key, value);
            return previous;
        }
        return __assign(__assign({}, previous), (_b = {}, _b[key] = value, _b));
    }, {});
});

var removeAllEventListeners = (function (ref, validateWithStateUpdate) {
    if (!ref.removeEventListener) {
        return;
    }
    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);
});

var isRadioInput = (function (type) { return type === RADIO_INPUT; });

var isCheckBoxInput = (function (type) { return type === 'checkbox'; });

function isDetached(element) {
    if (!element) {
        return true;
    }
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE) {
        return false;
    }
    return isDetached(element.parentNode);
}

function findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate, field, forceDelete) {
    if (validateWithStateUpdate === void 0) { validateWithStateUpdate = function () { }; }
    if (!field) {
        return;
    }
    var ref = field.ref, mutationWatcher = field.mutationWatcher, options = field.options;
    if (!ref.type) {
        return;
    }
    var name = ref.name, type = ref.type;
    if ((isRadioInput(type) || isCheckBoxInput(type)) && options) {
        options.forEach(function (_a, index) {
            var ref = _a.ref;
            var option = options[index];
            if ((option && isDetached(ref)) || forceDelete) {
                var mutationWatcher_1 = option.mutationWatcher;
                removeAllEventListeners(option, validateWithStateUpdate);
                if (mutationWatcher_1) {
                    mutationWatcher_1.disconnect();
                }
                options.splice(index, 1);
            }
        });
        if (!options.length) {
            delete fields[name];
        }
    }
    else if (isDetached(ref) || forceDelete) {
        removeAllEventListeners(ref, validateWithStateUpdate);
        if (mutationWatcher) {
            mutationWatcher.disconnect();
        }
        delete fields[name];
    }
}

var defaultReturn = {
    isValid: false,
    value: '',
};
var getRadioValue = (function (options) {
    return isArray(options)
        ? options.reduce(function (previous, _a) {
            var _b = _a.ref, checked = _b.checked, value = _b.value;
            return checked
                ? {
                    isValid: true,
                    value: value,
                }
                : previous;
        }, defaultReturn)
        : defaultReturn;
});

var getMultipleSelectValue = (function (options) {
    return __spread(options).filter(function (_a) {
        var selected = _a.selected;
        return selected;
    })
        .map(function (_a) {
        var value = _a.value;
        return value;
    });
});

var isMultipleSelect = (function (type) { return type === 'select-multiple'; });

var isEmptyString = (function (value) { return value === ''; });

var defaultResult = {
    value: false,
    isValid: false,
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (function (options) {
    if (isArray(options)) {
        if (options.length > 1) {
            var values = options
                .filter(function (_a) {
                var checked = _a.ref.checked;
                return checked;
            })
                .map(function (_a) {
                var value = _a.ref.value;
                return value;
            });
            return { value: values, isValid: !!values.length };
        }
        var _a = options[0].ref, checked = _a.checked, value = _a.value, valueAttribute = _a.attributes.value;
        return checked
            ? valueAttribute
                ? isUndefined(value) || isEmptyString(value)
                    ? validResult
                    : { value: value, isValid: true }
                : validResult
            : defaultResult;
    }
    return defaultResult;
});

function getFieldValue(fields, ref) {
    var type = ref.type, name = ref.name, options = ref.options, value = ref.value, files = ref.files;
    var field = fields[name];
    if (type === 'file') {
        return files;
    }
    if (isRadioInput(type)) {
        return field ? getRadioValue(field.options).value : '';
    }
    if (isMultipleSelect(type)) {
        return getMultipleSelectValue(options);
    }
    if (isCheckBoxInput(type)) {
        return field ? getCheckboxValue(field.options).value : false;
    }
    return value;
}

var getFieldsValues = (function (fields) {
    return Object.values(fields).reduce(function (previous, _a) {
        var _b;
        var ref = _a.ref, name = _a.ref.name;
        return (__assign(__assign({}, previous), (_b = {}, _b[name] = getFieldValue(fields, ref), _b)));
    }, {});
});

var isEmptyObject = (function (value) {
    return isObject(value) && !Object.keys(value).length;
});

var isSameError = (function (error, type, message) {
    return isObject(error) && error.type === type && error.message === message;
});

function shouldUpdateWithError(_a) {
    var errors = _a.errors, name = _a.name, error = _a.error, validFields = _a.validFields, fieldsWithValidation = _a.fieldsWithValidation, schemaErrors = _a.schemaErrors;
    var isFieldValid = isEmptyObject(error);
    var isFormValid = isEmptyObject(errors);
    var currentFieldError = error[name];
    var existFieldError = errors[name];
    if ((isFieldValid && validFields.has(name)) ||
        (existFieldError && existFieldError.isManual)) {
        return false;
    }
    if (isFormValid !== isFieldValid ||
        (!isFormValid && !existFieldError) ||
        (isFieldValid &&
            fieldsWithValidation.has(name) &&
            !validFields.has(name)) ||
        (schemaErrors && isEmptyObject(schemaErrors) !== isFormValid)) {
        return true;
    }
    return (currentFieldError &&
        !isSameError(existFieldError, currentFieldError.type, currentFieldError.message));
}

var isRegex = (function (value) { return value instanceof RegExp; });

var getValueAndMessage = (function (validationData) {
    var isPureObject = isObject(validationData) && !isRegex(validationData);
    return {
        value: isPureObject
            ? validationData.value
            : validationData,
        message: isPureObject
            ? validationData.message
            : '',
    };
});

var isString = (function (value) { return typeof value === 'string'; });

var displayNativeError = (function (nativeValidation, ref, message) {
    if (nativeValidation && isString(message)) {
        ref.setCustomValidity(message);
    }
});

var isFunction = (function (value) {
    return typeof value === 'function';
});

var isBoolean = (function (value) { return typeof value === 'boolean'; });

function getValidateError(result, ref, nativeError, type) {
    if (type === void 0) { type = 'validate'; }
    var isStringValue = isString(result);
    if (isStringValue || (isBoolean(result) && !result)) {
        var message = isStringValue ? result : '';
        var error = {
            type: type,
            message: message,
            ref: ref,
        };
        nativeError(message);
        return error;
    }
}

var appendErrors = (function (name, validateAllFieldCriteria, errors, type, message) {
    var _a;
    if (!validateAllFieldCriteria) {
        return {};
    }
    var error = errors[name] || { types: {} };
    return __assign(__assign({}, error), { types: __assign(__assign({}, error.types), (_a = {}, _a[type] = message || true, _a)) });
});

var validateField = (function (fields, nativeValidation, validateAllFieldCriteria, _a) {
    var ref = _a.ref, _b = _a.ref, type = _b.type, value = _b.value, name = _b.name, options = _a.options, required = _a.required, maxLength = _a.maxLength, minLength = _a.minLength, min = _a.min, max = _a.max, pattern = _a.pattern, validate = _a.validate;
    return __awaiter(void 0, void 0, void 0, function () {
        var error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, nativeError, typedName, appendErrorsCurry, message, exceedMax, exceedMin, _c, maxValue, maxMessage, _d, minValue, minMessage, valueNumber, message, _e, maxLengthValue, maxLengthMessage, _f, minLengthValue, minLengthMessage, inputLength, exceedMax, exceedMin, message, _g, patternValue, patternMessage, fieldValue_1, validateRef_1, result, validateError, validateFunctions_1, validationResult;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    error = {};
                    isRadio = isRadioInput(type);
                    isCheckBox = isCheckBoxInput(type);
                    isRadioOrCheckbox = isRadio || isCheckBox;
                    isEmpty = isEmptyString(value);
                    nativeError = displayNativeError.bind(null, nativeValidation, ref);
                    typedName = name;
                    appendErrorsCurry = appendErrors.bind(null, typedName, validateAllFieldCriteria, error);
                    if (required &&
                        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||
                            (isCheckBox && !getCheckboxValue(options).isValid) ||
                            (isRadio && !getRadioValue(options).isValid))) {
                        message = isString(required) ? required : '';
                        error[typedName] = __assign({ type: INPUT_VALIDATION_RULES.required, message: message, ref: isRadioOrCheckbox ? fields[typedName].options[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
                        nativeError(message);
                        if (!validateAllFieldCriteria) {
                            return [2 /*return*/, error];
                        }
                    }
                    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
                        exceedMax = void 0;
                        exceedMin = void 0;
                        _c = getValueAndMessage(max), maxValue = _c.value, maxMessage = _c.message;
                        _d = getValueAndMessage(min), minValue = _d.value, minMessage = _d.message;
                        if (type === 'number') {
                            valueNumber = parseFloat(value);
                            if (!isNullOrUndefined(maxValue)) {
                                exceedMax = valueNumber > maxValue;
                            }
                            if (!isNullOrUndefined(minValue)) {
                                exceedMin = valueNumber < minValue;
                            }
                        }
                        else {
                            if (isString(maxValue)) {
                                exceedMax = new Date(value) > new Date(maxValue);
                            }
                            if (isString(minValue)) {
                                exceedMin = new Date(value) < new Date(minValue);
                            }
                        }
                        if (exceedMax || exceedMin) {
                            message = exceedMax ? maxMessage : minMessage;
                            error[typedName] = __assign({ type: exceedMax
                                    ? INPUT_VALIDATION_RULES.max
                                    : INPUT_VALIDATION_RULES.min, message: message,
                                ref: ref }, (exceedMax
                                ? appendErrorsCurry(INPUT_VALIDATION_RULES.max, message)
                                : appendErrorsCurry(INPUT_VALIDATION_RULES.min, message)));
                            nativeError(message);
                            if (!validateAllFieldCriteria) {
                                return [2 /*return*/, error];
                            }
                        }
                    }
                    if (isString(value) && !isEmpty && (maxLength || minLength)) {
                        _e = getValueAndMessage(maxLength), maxLengthValue = _e.value, maxLengthMessage = _e.message;
                        _f = getValueAndMessage(minLength), minLengthValue = _f.value, minLengthMessage = _f.message;
                        inputLength = value.toString().length;
                        exceedMax = maxLength && inputLength > maxLengthValue;
                        exceedMin = minLength && inputLength < minLengthValue;
                        if (exceedMax || exceedMin) {
                            message = exceedMax ? maxLengthMessage : minLengthMessage;
                            error[typedName] = __assign({ type: exceedMax
                                    ? INPUT_VALIDATION_RULES.maxLength
                                    : INPUT_VALIDATION_RULES.minLength, message: message,
                                ref: ref }, (exceedMax
                                ? appendErrorsCurry(INPUT_VALIDATION_RULES.maxLength, message)
                                : appendErrorsCurry(INPUT_VALIDATION_RULES.minLength, message)));
                            nativeError(message);
                            if (!validateAllFieldCriteria) {
                                return [2 /*return*/, error];
                            }
                        }
                    }
                    if (pattern && !isEmpty) {
                        _g = getValueAndMessage(pattern), patternValue = _g.value, patternMessage = _g.message;
                        if (isRegex(patternValue) && !patternValue.test(value)) {
                            error[typedName] = __assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref: ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));
                            nativeError(patternMessage);
                            if (!validateAllFieldCriteria) {
                                return [2 /*return*/, error];
                            }
                        }
                    }
                    if (!validate) return [3 /*break*/, 4];
                    fieldValue_1 = getFieldValue(fields, ref);
                    validateRef_1 = isRadioOrCheckbox && options ? options[0].ref : ref;
                    if (!isFunction(validate)) return [3 /*break*/, 2];
                    return [4 /*yield*/, validate(fieldValue_1)];
                case 1:
                    result = _h.sent();
                    validateError = getValidateError(result, validateRef_1, nativeError);
                    if (validateError) {
                        error[typedName] = __assign(__assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
                        if (!validateAllFieldCriteria) {
                            return [2 /*return*/, error];
                        }
                    }
                    return [3 /*break*/, 4];
                case 2:
                    if (!isObject(validate)) return [3 /*break*/, 4];
                    validateFunctions_1 = Object.entries(validate);
                    return [4 /*yield*/, new Promise(function (resolve) {
                            validateFunctions_1.reduce(function (previous, _a, index) {
                                var _b = __read(_a, 2), key = _b[0], validate = _b[1];
                                return __awaiter(void 0, void 0, void 0, function () {
                                    var _c, result, validateResult, validateError;
                                    return __generator(this, function (_d) {
                                        switch (_d.label) {
                                            case 0:
                                                _c = isEmptyObject;
                                                return [4 /*yield*/, previous];
                                            case 1:
                                                if ((!_c.apply(void 0, [_d.sent()]) && !validateAllFieldCriteria) ||
                                                    !isFunction(validate)) {
                                                    return [2 /*return*/, resolve(previous)];
                                                }
                                                return [4 /*yield*/, validate(fieldValue_1)];
                                            case 2:
                                                validateResult = _d.sent();
                                                validateError = getValidateError(validateResult, validateRef_1, nativeError, key);
                                                if (validateError) {
                                                    result = __assign(__assign({}, validateError), appendErrorsCurry(key, validateError.message));
                                                    if (validateAllFieldCriteria) {
                                                        error[typedName] = result;
                                                    }
                                                }
                                                else {
                                                    result = previous;
                                                }
                                                return [2 /*return*/, validateFunctions_1.length - 1 === index
                                                        ? resolve(result)
                                                        : result];
                                        }
                                    });
                                });
                            }, {});
                        })];
                case 3:
                    validationResult = _h.sent();
                    if (!isEmptyObject(validationResult)) {
                        error[typedName] = __assign({ ref: validateRef_1 }, validationResult);
                        if (!validateAllFieldCriteria) {
                            return [2 /*return*/, error];
                        }
                    }
                    _h.label = 4;
                case 4:
                    if (nativeValidation) {
                        ref.setCustomValidity('');
                    }
                    return [2 /*return*/, error];
            }
        });
    });
});

var parseErrorSchema = function (error, validateAllFieldCriteria) {
    var _a;
    return isArray(error.inner)
        ? error.inner.reduce(function (previous, _a) {
            var _b, _c, _d;
            var path = _a.path, message = _a.message, type = _a.type;
            return (__assign(__assign({}, previous), (previous[path] && validateAllFieldCriteria
                ? (_b = {},
                    _b[path] = appendErrors(path, validateAllFieldCriteria, previous, type, message),
                    _b) : (_c = {},
                _c[path] = __assign({ message: message,
                    type: type }, (validateAllFieldCriteria
                    ? {
                        types: (_d = {}, _d[type] = message || true, _d),
                    }
                    : {})),
                _c))));
        }, {})
        : (_a = {},
            _a[error.path] = { message: error.message, type: error.type },
            _a);
};
function validateWithSchema(validationSchema, validationSchemaOption, validateAllFieldCriteria, data) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = {};
                    return [4 /*yield*/, validationSchema.validate(data, validationSchemaOption)];
                case 1: return [2 /*return*/, (_a.result = _b.sent(),
                        _a.fieldErrors = {},
                        _a)];
                case 2:
                    e_1 = _b.sent();
                    return [2 /*return*/, {
                            result: {},
                            fieldErrors: parseErrorSchema(e_1, validateAllFieldCriteria),
                        }];
                case 3: return [2 /*return*/];
            }
        });
    });
}

function attachNativeValidation(ref, rules) {
    Object.entries(rules).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (key === INPUT_VALIDATION_RULES.pattern && isRegex(value)) {
            ref[key] = value.source;
        }
        else {
            ref[key] = key === INPUT_VALIDATION_RULES.pattern || value;
        }
    });
}

var get = (function (obj, path, defaultValue) {
    var result = path
        .split(/[,[\].]+?/)
        .filter(Boolean)
        .reduce(function (result, key) { return (isNullOrUndefined(result) ? result : result[key]); }, obj);
    return isUndefined(result) || result === obj ? defaultValue : result;
});

var getDefaultValue = (function (defaultValues, name, defaultValue) {
    return isUndefined(defaultValues[name])
        ? get(defaultValues, name, defaultValue)
        : defaultValues[name];
});

function flatArray(list) {
    return list.reduce(function (a, b) { return a.concat(isArray(b) ? flatArray(b) : b); }, []);
}

var getPath = function (path, values) {
    return isArray(values)
        ? values.map(function (item, index) {
            var pathWithIndex = path + "[" + index + "]";
            if (isArray(item)) {
                return getPath(pathWithIndex, item);
            }
            else if (isObject(item)) {
                return Object.entries(item).map(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
                    return isString(objectValue)
                        ? pathWithIndex + "." + key
                        : getPath(pathWithIndex + "." + key, objectValue);
                });
            }
            return pathWithIndex;
        })
        : Object.entries(values).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
            return isString(objectValue) ? path + "." + key : getPath(path, objectValue);
        });
};
var getPath$1 = (function (parentPath, value) { return flatArray(getPath(parentPath, value)); });

var assignWatchFields = (function (fieldValues, fieldName, watchFields, combinedDefaultValues) {
    var value;
    if (isEmptyObject(fieldValues)) {
        value = undefined;
    }
    else if (!isUndefined(fieldValues[fieldName])) {
        watchFields.add(fieldName);
        value = fieldValues[fieldName];
    }
    else {
        value = get(combineFieldValues(fieldValues), fieldName);
        if (!isUndefined(value)) {
            getPath$1(fieldName, value).forEach(function (name) {
                return watchFields.add(name);
            });
        }
    }
    return isUndefined(value)
        ? getDefaultValue(combinedDefaultValues, fieldName)
        : value;
});

var omitValidFields = (function (errorFields, validFieldNames) {
    return Object.entries(errorFields).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), name = _c[0], error = _c[1];
        return validFieldNames.some(function (validFieldName) { return validFieldName === name; })
            ? previous
            : __assign(__assign({}, previous), (_b = {}, _b[name] = error, _b));
    }, {});
});

function onDomRemove(element, onDetachCallback) {
    var observer = new MutationObserver(function () {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (function (mode) { return ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
}); });

var useRef = React.useRef, useState = React.useState, useCallback = React.useCallback, useEffect = React.useEffect;
function useForm(_a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.mode, mode = _c === void 0 ? VALIDATION_MODE.onSubmit : _c, _d = _b.reValidateMode, reValidateMode = _d === void 0 ? VALIDATION_MODE.onChange : _d, validationSchema = _b.validationSchema, _e = _b.defaultValues, defaultValues = _e === void 0 ? {} : _e, _f = _b.nativeValidation, nativeValidation = _f === void 0 ? false : _f, _g = _b.submitFocusError, submitFocusError = _g === void 0 ? true : _g, _h = _b.validationSchemaOption, validationSchemaOption = _h === void 0 ? { abortEarly: false } : _h, validateCriteriaMode = _b.validateCriteriaMode;
    var fieldsRef = useRef({});
    var validateAllFieldCriteria = validateCriteriaMode === 'all';
    var errorsRef = useRef({});
    var schemaErrorsRef = useRef({});
    var touchedFieldsRef = useRef(new Set());
    var watchFieldsRef = useRef(new Set());
    var dirtyFieldsRef = useRef(new Set());
    var fieldsWithValidationRef = useRef(new Set());
    var validFieldsRef = useRef(new Set());
    var defaultValuesRef = useRef({});
    var isUnMount = useRef(false);
    var isWatchAllRef = useRef(false);
    var isSubmittedRef = useRef(false);
    var isDirtyRef = useRef(false);
    var submitCountRef = useRef(0);
    var isSubmittingRef = useRef(false);
    var isSchemaValidateTriggeredRef = useRef(false);
    var validateAndUpdateStateRef = useRef();
    var _j = __read(useState(), 2), _render = _j[1];
    var _k = useRef(modeChecker(mode)).current, isOnBlur = _k.isOnBlur, isOnSubmit = _k.isOnSubmit;
    var isWindowUndefined = typeof window === UNDEFINED;
    var isWeb = typeof document !== UNDEFINED &&
        !isWindowUndefined &&
        !isUndefined(window.HTMLElement);
    var isProxyEnabled = !isWindowUndefined && 'Proxy' in window;
    var readFormState = useRef({
        dirty: !isProxyEnabled,
        isSubmitted: isOnSubmit,
        submitCount: !isProxyEnabled,
        touched: !isProxyEnabled,
        isSubmitting: !isProxyEnabled,
        isValid: !isProxyEnabled,
    });
    var _l = useRef(modeChecker(reValidateMode)).current, isReValidateOnBlur = _l.isOnBlur, isReValidateOnSubmit = _l.isOnSubmit;
    var validationSchemaOptionRef = useRef(validationSchemaOption);
    var combineErrorsRef = function (data) { return (__assign(__assign({}, errorsRef.current), data)); };
    var render = useCallback(function () {
        if (!isUnMount.current) {
            _render({});
        }
    }, []);
    var validateFieldCurry = useCallback(validateField.bind(null, fieldsRef.current, nativeValidation, validateAllFieldCriteria), []);
    var validateWithSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current, validateAllFieldCriteria), [validationSchema]);
    var renderBaseOnError = useCallback(function (name, error, shouldRender) {
        var reRender = shouldRender ||
            shouldUpdateWithError({
                errors: errorsRef.current,
                error: error,
                name: name,
                validFields: validFieldsRef.current,
                fieldsWithValidation: fieldsWithValidationRef.current,
                schemaErrors: isSchemaValidateTriggeredRef.current && schemaErrorsRef.current,
            });
        if (isEmptyObject(error)) {
            if (fieldsWithValidationRef.current.has(name) || validationSchema) {
                validFieldsRef.current.add(name);
                reRender = reRender || errorsRef.current[name];
            }
            delete errorsRef.current[name];
        }
        else {
            validFieldsRef.current.delete(name);
            reRender = reRender || !errorsRef.current[name];
        }
        errorsRef.current = validationSchema
            ? schemaErrorsRef.current
            : combineErrorsRef(error);
        if (reRender) {
            render();
            return true;
        }
    }, [render, validationSchema]);
    var setFieldValue = useCallback(function (name, rawValue) {
        var field = fieldsRef.current[name];
        if (!field) {
            return false;
        }
        var ref = field.ref;
        var type = ref.type;
        var options = field.options;
        var value = isWeb &&
            ref instanceof window.HTMLElement &&
            isNullOrUndefined(rawValue)
            ? ''
            : rawValue;
        if (isRadioInput(type) && options) {
            options.forEach(function (_a) {
                var radioRef = _a.ref;
                return (radioRef.checked = radioRef.value === value);
            });
        }
        else if (isMultipleSelect(type)) {
            __spread(ref.options).forEach(function (selectRef) {
                return (selectRef.selected = value.includes(selectRef.value));
            });
        }
        else if (isCheckBoxInput(type) && options) {
            options.length > 1
                ? options.forEach(function (_a) {
                    var checkboxRef = _a.ref;
                    return (checkboxRef.checked = value.includes(checkboxRef.value));
                })
                : (options[0].ref.checked = !!value);
        }
        else {
            ref.value = value;
        }
        return type;
    }, [isWeb]);
    var setDirty = function (name) {
        if (!fieldsRef.current[name]) {
            return false;
        }
        var isDirty = defaultValuesRef.current[name] !==
            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
        var isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;
        if (isDirty) {
            dirtyFieldsRef.current.add(name);
        }
        else {
            dirtyFieldsRef.current.delete(name);
        }
        isDirtyRef.current = !!dirtyFieldsRef.current.size;
        return isDirtyChanged && readFormState.current.dirty;
    };
    var setInternalValue = useCallback(function (name, value) {
        setFieldValue(name, value);
        if (setDirty(name) ||
            (!touchedFieldsRef.current.has(name) && readFormState.current.touched)) {
            return !!touchedFieldsRef.current.add(name);
        }
    }, [setFieldValue]);
    var executeValidation = useCallback(function (_a, shouldRender) {
        var name = _a.name, value = _a.value;
        return __awaiter(_this, void 0, void 0, function () {
            var field, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        field = fieldsRef.current[name];
                        if (!field) {
                            return [2 /*return*/, false];
                        }
                        if (!isUndefined(value)) {
                            setInternalValue(name, value);
                        }
                        if (shouldRender) {
                            render();
                        }
                        return [4 /*yield*/, validateFieldCurry(field)];
                    case 1:
                        error = _b.sent();
                        renderBaseOnError(name, error);
                        return [2 /*return*/, isEmptyObject(error)];
                }
            });
        });
    }, [render, renderBaseOnError, setInternalValue, validateFieldCurry]);
    var executeSchemaValidation = useCallback(function (payload) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, isMultipleFields, names, validFieldNames, firstFieldName;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current)))];
                case 1:
                    fieldErrors = (_b.sent()).fieldErrors;
                    isMultipleFields = isArray(payload);
                    names = isArray(payload)
                        ? payload.map(function (_a) {
                            var name = _a.name;
                            return name;
                        })
                        : [payload.name];
                    validFieldNames = names.filter(function (name) { return !fieldErrors[name]; });
                    firstFieldName = names[0];
                    schemaErrorsRef.current = isMultipleFields
                        ? fieldErrors
                        : fieldErrors[firstFieldName]
                            ? (_a = {}, _a[firstFieldName] = fieldErrors[firstFieldName], _a) : {};
                    isSchemaValidateTriggeredRef.current = true;
                    if (isMultipleFields) {
                        errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)
                            .filter(function (_a) {
                            var _b = __read(_a, 1), key = _b[0];
                            return names.includes(key);
                        })
                            .reduce(function (previous, _a) {
                            var _b;
                            var _c = __read(_a, 2), name = _c[0], error = _c[1];
                            return (__assign(__assign({}, previous), (_b = {}, _b[name] = error, _b)));
                        }, {})), validFieldNames);
                        render();
                    }
                    else {
                        renderBaseOnError(firstFieldName, schemaErrorsRef.current);
                    }
                    return [2 /*return*/, isEmptyObject(errorsRef.current)];
            }
        });
    }); }, [render, renderBaseOnError, validateWithSchemaCurry]);
    var triggerValidation = useCallback(function (payload, shouldRender) { return __awaiter(_this, void 0, void 0, function () {
        var fields, result;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fields = payload || Object.keys(fieldsRef.current).map(function (name) { return ({ name: name }); });
                    if (validationSchema) {
                        return [2 /*return*/, executeSchemaValidation(fields)];
                    }
                    if (!isArray(fields)) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(fields.map(function (data) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, executeValidation(data, false)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); }))];
                case 1:
                    result = _a.sent();
                    render();
                    return [2 /*return*/, result.every(Boolean)];
                case 2: return [4 /*yield*/, executeValidation(fields, shouldRender)];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    }); }, [executeSchemaValidation, executeValidation, render, validationSchema]);
    var setValue = useCallback(function (name, value, shouldValidate) {
        var shouldRender = setInternalValue(name, value) ||
            isWatchAllRef.current ||
            watchFieldsRef.current.has(name);
        if (shouldValidate) {
            return triggerValidation({ name: name }, shouldRender);
        }
        if (shouldRender) {
            render();
        }
        return;
    }, [render, setInternalValue, triggerValidation]);
    validateAndUpdateStateRef.current = validateAndUpdateStateRef.current
        ? validateAndUpdateStateRef.current
        : function (_a) {
            var type = _a.type, target = _a.target;
            return __awaiter(_this, void 0, void 0, function () {
                var name, fields, errors, field, currentError, error, isBlurEvent, shouldSkipValidation, shouldUpdateDirty, shouldUpdateState, fieldErrors;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            name = target ? target.name : '';
                            fields = fieldsRef.current;
                            errors = errorsRef.current;
                            field = fields[name];
                            currentError = errors[name];
                            if (!field) {
                                return [2 /*return*/];
                            }
                            isBlurEvent = type === EVENTS.BLUR;
                            shouldSkipValidation = (isOnSubmit && !isSubmittedRef.current) ||
                                (isOnBlur && !isBlurEvent && !currentError) ||
                                (isReValidateOnBlur && !isBlurEvent && currentError) ||
                                (isReValidateOnSubmit && currentError);
                            shouldUpdateDirty = setDirty(name);
                            shouldUpdateState = isWatchAllRef.current ||
                                watchFieldsRef.current.has(name) ||
                                shouldUpdateDirty;
                            if (isBlurEvent &&
                                !touchedFieldsRef.current.has(name) &&
                                readFormState.current.touched) {
                                touchedFieldsRef.current.add(name);
                                shouldUpdateState = true;
                            }
                            if (shouldSkipValidation) {
                                return [2 /*return*/, shouldUpdateState && render()];
                            }
                            if (!validationSchema) return [3 /*break*/, 2];
                            return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields)))];
                        case 1:
                            fieldErrors = (_c.sent()).fieldErrors;
                            Object.keys(fieldErrors).forEach(function (name) {
                                return validFieldsRef.current.delete(name);
                            });
                            schemaErrorsRef.current = fieldErrors;
                            isSchemaValidateTriggeredRef.current = true;
                            error = fieldErrors[name] ? (_b = {}, _b[name] = fieldErrors[name], _b) : {};
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, validateFieldCurry(field)];
                        case 3:
                            error = _c.sent();
                            _c.label = 4;
                        case 4:
                            if (!renderBaseOnError(name, error) && shouldUpdateState) {
                                render();
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
    var resetFieldRef = useCallback(function (name) {
        delete errorsRef.current[name];
        delete fieldsRef.current[name];
        delete defaultValuesRef.current[name];
        [
            touchedFieldsRef,
            dirtyFieldsRef,
            fieldsWithValidationRef,
            validFieldsRef,
            watchFieldsRef,
        ].forEach(function (data) { return data.current.delete(name); });
        if (readFormState.current.isValid || readFormState.current.touched) {
            render();
        }
    }, [render]);
    var removeEventListenerAndRef = useCallback(function (field, forceDelete) {
        if (!field) {
            return;
        }
        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);
        resetFieldRef(field.ref.name);
    }, [resetFieldRef]);
    function clearError(name) {
        if (isUndefined(name)) {
            errorsRef.current = {};
        }
        else {
            (isArray(name) ? name : [name]).forEach(function (fieldName) { return delete errorsRef.current[fieldName]; });
        }
        render();
    }
    var setInternalError = function (_a) {
        var name = _a.name, type = _a.type, types = _a.types, message = _a.message, preventRender = _a.preventRender;
        var errors = errorsRef.current;
        if (!isSameError(errors[name], type, message)) {
            errors[name] = {
                type: type,
                types: types,
                message: message,
                ref: {},
                isManual: true,
            };
            if (!preventRender) {
                render();
            }
        }
    };
    function setError(name, type, message) {
        if (type === void 0) { type = ''; }
        if (isString(name)) {
            setInternalError(__assign({ name: name }, (isObject(type)
                ? {
                    types: type,
                    type: '',
                }
                : {
                    type: type,
                    message: message,
                })));
        }
        else if (isArray(name)) {
            name.forEach(function (error) {
                return setInternalError(__assign(__assign({}, error), { preventRender: true }));
            });
            render();
        }
    }
    function watch(fieldNames, defaultValue) {
        var combinedDefaultValues = isUndefined(defaultValue)
            ? isUndefined(defaultValues)
                ? {}
                : defaultValues
            : defaultValue;
        var fieldValues = getFieldsValues(fieldsRef.current);
        var watchFields = watchFieldsRef.current;
        if (isProxyEnabled) {
            readFormState.current.dirty = true;
        }
        if (isString(fieldNames)) {
            return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues);
        }
        if (isArray(fieldNames)) {
            return fieldNames.reduce(function (previous, name) {
                var _a;
                var value = null;
                if (isEmptyObject(fieldsRef.current) &&
                    isObject(combinedDefaultValues)) {
                    value = getDefaultValue(combinedDefaultValues, name);
                }
                else {
                    value = assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues);
                }
                return __assign(__assign({}, previous), (_a = {}, _a[name] = value, _a));
            }, {});
        }
        isWatchAllRef.current = true;
        return ((!isEmptyObject(fieldValues) && fieldValues) ||
            defaultValue ||
            defaultValues);
    }
    function registerIntoFieldsRef(ref, validateOptions) {
        if (validateOptions === void 0) { validateOptions = {}; }
        if (!ref.name) {
            return console.warn('Missing name at', ref);
        }
        var name = ref.name, type = ref.type, value = ref.value;
        var fieldAttributes = __assign({ ref: ref }, validateOptions);
        var fields = fieldsRef.current;
        var isRadioOrCheckbox = isRadioInput(type) || isCheckBoxInput(type);
        var currentField = fields[name];
        if (isRadioOrCheckbox
            ? currentField &&
                isArray(currentField.options) &&
                currentField.options.find(function (_a) {
                    var ref = _a.ref;
                    return value === ref.value;
                })
            : currentField) {
            fields[name] = __assign(__assign({}, currentField), validateOptions);
            return;
        }
        if (type) {
            var mutationWatcher = onDomRemove(ref, function () {
                return removeEventListenerAndRef(fieldAttributes);
            });
            if (isRadioOrCheckbox) {
                currentField = __assign({ options: __spread(((currentField && currentField.options) || []), [
                        {
                            ref: ref,
                            mutationWatcher: mutationWatcher,
                        },
                    ]), ref: { type: type, name: name } }, validateOptions);
            }
            else {
                currentField = __assign(__assign({}, fieldAttributes), { mutationWatcher: mutationWatcher });
            }
        }
        else {
            currentField = fieldAttributes;
        }
        fields[name] = currentField;
        if (!isEmptyObject(defaultValues)) {
            var defaultValue = getDefaultValue(defaultValues, name);
            if (!isUndefined(defaultValue)) {
                setFieldValue(name, defaultValue);
            }
        }
        if (!isEmptyObject(validateOptions)) {
            fieldsWithValidationRef.current.add(name);
            if (!isOnSubmit && readFormState.current.isValid) {
                if (validationSchema) {
                    isSchemaValidateTriggeredRef.current = true;
                    validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))).then(function (_a) {
                        var fieldErrors = _a.fieldErrors;
                        schemaErrorsRef.current = fieldErrors;
                        if (isEmptyObject(schemaErrorsRef.current)) {
                            render();
                        }
                    });
                }
                else {
                    validateFieldCurry(currentField).then(function (error) {
                        if (isEmptyObject(error)) {
                            validFieldsRef.current.add(name);
                        }
                        if (validFieldsRef.current.size <=
                            fieldsWithValidationRef.current.size) {
                            render();
                        }
                    });
                }
            }
        }
        if (!defaultValuesRef.current[name]) {
            defaultValuesRef.current[name] = getFieldValue(fields, currentField.ref);
        }
        if (!type) {
            return;
        }
        var fieldToAttachListener = isRadioOrCheckbox && currentField.options
            ? currentField.options[currentField.options.length - 1]
            : currentField;
        if (nativeValidation && validateOptions) {
            attachNativeValidation(ref, validateOptions);
        }
        else {
            attachEventListeners({
                field: fieldToAttachListener,
                isRadioOrCheckbox: isRadioOrCheckbox,
                validateAndStateUpdate: validateAndUpdateStateRef.current,
            });
        }
    }
    function register(refOrValidateRule, validationOptions) {
        if (isWindowUndefined || !refOrValidateRule) {
            return;
        }
        if (validationOptions && isString(validationOptions.name)) {
            registerIntoFieldsRef({ name: validationOptions.name }, validationOptions);
            return;
        }
        if (isObject(refOrValidateRule) && 'name' in refOrValidateRule) {
            registerIntoFieldsRef(refOrValidateRule, validationOptions);
            return;
        }
        return function (ref) {
            return ref && registerIntoFieldsRef(ref, refOrValidateRule);
        };
    }
    function unregister(names) {
        if (!isEmptyObject(fieldsRef.current)) {
            (isArray(names) ? names : [names]).forEach(function (fieldName) {
                return removeEventListenerAndRef(fieldsRef.current[fieldName], true);
            });
        }
    }
    var handleSubmit = function (callback) { return function (e) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, fieldValues, fields, output, _a, errors, values;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (e) {
                        e.preventDefault();
                        e.persist();
                    }
                    fields = fieldsRef.current;
                    if (readFormState.current.isSubmitting) {
                        isSubmittingRef.current = true;
                        render();
                    }
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 9, 10]);
                    if (!validationSchema) return [3 /*break*/, 3];
                    fieldValues = getFieldsValues(fields);
                    return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(fieldValues))];
                case 2:
                    output = _b.sent();
                    schemaErrorsRef.current = output.fieldErrors;
                    fieldErrors = output.fieldErrors;
                    fieldValues = output.result;
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, Object.values(fields).reduce(function (previous, field) { return __awaiter(_this, void 0, void 0, function () {
                        var resolvedPrevious, ref, name, fieldError;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!field) {
                                        return [2 /*return*/, previous];
                                    }
                                    return [4 /*yield*/, previous];
                                case 1:
                                    resolvedPrevious = _a.sent();
                                    ref = field.ref, name = field.ref.name;
                                    if (!fields[name]) {
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    }
                                    return [4 /*yield*/, validateFieldCurry(field)];
                                case 2:
                                    fieldError = _a.sent();
                                    if (fieldError[name]) {
                                        resolvedPrevious.errors = __assign(__assign({}, resolvedPrevious.errors), fieldError);
                                        validFieldsRef.current.delete(name);
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    }
                                    if (fieldsWithValidationRef.current.has(name)) {
                                        validFieldsRef.current.add(name);
                                    }
                                    resolvedPrevious.values[name] = getFieldValue(fields, ref);
                                    return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                            }
                        });
                    }); }, Promise.resolve({
                        errors: {},
                        values: {},
                    }))];
                case 4:
                    _a = _b.sent(), errors = _a.errors, values = _a.values;
                    fieldErrors = errors;
                    fieldValues = values;
                    _b.label = 5;
                case 5:
                    if (!isEmptyObject(fieldErrors)) return [3 /*break*/, 7];
                    errorsRef.current = {};
                    return [4 /*yield*/, callback(combineFieldValues(fieldValues), e)];
                case 6:
                    _b.sent();
                    return [3 /*break*/, 8];
                case 7:
                    if (submitFocusError) {
                        Object.keys(fieldErrors).reduce(function (previous, current) {
                            var field = fields[current];
                            if (field && field.ref.focus && previous) {
                                field.ref.focus();
                                return false;
                            }
                            return previous;
                        }, true);
                    }
                    errorsRef.current = fieldErrors;
                    _b.label = 8;
                case 8: return [3 /*break*/, 10];
                case 9:
                    isSubmittedRef.current = true;
                    isSubmittingRef.current = false;
                    submitCountRef.current = submitCountRef.current + 1;
                    render();
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/];
            }
        });
    }); }; };
    var resetRefs = function () {
        errorsRef.current = {};
        defaultValuesRef.current = {};
        schemaErrorsRef.current = {};
        touchedFieldsRef.current = new Set();
        watchFieldsRef.current = new Set();
        dirtyFieldsRef.current = new Set();
        validFieldsRef.current = new Set();
        isWatchAllRef.current = false;
        isSubmittedRef.current = false;
        isDirtyRef.current = false;
        isSchemaValidateTriggeredRef.current = false;
        submitCountRef.current = 0;
    };
    var reset = useCallback(function (values) {
        var e_1, _a;
        var fieldsKeyValue = Object.entries(fieldsRef.current);
        try {
            for (var fieldsKeyValue_1 = __values(fieldsKeyValue), fieldsKeyValue_1_1 = fieldsKeyValue_1.next(); !fieldsKeyValue_1_1.done; fieldsKeyValue_1_1 = fieldsKeyValue_1.next()) {
                var _b = __read(fieldsKeyValue_1_1.value, 2), value = _b[1];
                if (value && value.ref && value.ref.closest) {
                    try {
                        value.ref.closest('form').reset();
                        break;
                    }
                    catch (_c) { }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (fieldsKeyValue_1_1 && !fieldsKeyValue_1_1.done && (_a = fieldsKeyValue_1.return)) _a.call(fieldsKeyValue_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        resetRefs();
        if (values) {
            fieldsKeyValue.forEach(function (_a) {
                var _b = __read(_a, 1), key = _b[0];
                return setFieldValue(key, getDefaultValue(values, key));
            });
            defaultValuesRef.current = __assign({}, values);
        }
        render();
    }, [render, setFieldValue]);
    var getValues = function (payload) {
        var fieldValues = getFieldsValues(fieldsRef.current);
        var outputValues = isEmptyObject(fieldValues)
            ? defaultValues
            : fieldValues;
        return payload && payload.nest
            ? combineFieldValues(outputValues)
            : outputValues;
    };
    useEffect(function () { return function () {
        isUnMount.current = true;
        fieldsRef.current &&
            Object.values(fieldsRef.current).forEach(function (field) {
                return removeEventListenerAndRef(field, true);
            });
    }; }, [removeEventListenerAndRef]);
    var formState = __assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: __spread(touchedFieldsRef.current), isSubmitting: isSubmittingRef.current }, (isOnSubmit
        ? {
            isValid: isSubmittedRef.current && isEmptyObject(errorsRef.current),
        }
        : {
            isValid: validationSchema
                ? isSchemaValidateTriggeredRef.current &&
                    isEmptyObject(schemaErrorsRef.current)
                : fieldsWithValidationRef.current.size
                    ? !isEmptyObject(fieldsRef.current) &&
                        validFieldsRef.current.size >=
                            fieldsWithValidationRef.current.size
                    : !isEmptyObject(fieldsRef.current),
        }));
    return {
        register: useCallback(register, []),
        unregister: useCallback(unregister, [removeEventListenerAndRef]),
        handleSubmit: handleSubmit,
        watch: watch,
        reset: reset,
        clearError: clearError,
        setError: useCallback(setError, []),
        setValue: setValue,
        triggerValidation: triggerValidation,
        getValues: getValues,
        errors: errorsRef.current,
        formState: isProxyEnabled
            ? new Proxy(formState, {
                get: function (obj, prop) {
                    if (prop in obj) {
                        readFormState.current[prop] = true;
                        return obj[prop];
                    }
                    return {};
                },
            })
            : formState,
    };
}

var FormGlobalContext = React.createContext(null);
function useFormContext() {
    return React.useContext(FormGlobalContext);
}
function FormContext(props) {
    var children = props.children, formState = props.formState, errors = props.errors, restMethods = __rest(props, ["children", "formState", "errors"]);
    var restRef = React.useRef(restMethods);
    return (React.createElement(FormGlobalContext.Provider, { value: __assign(__assign({}, restRef.current), { formState: formState, errors: errors }) }, children));
}

exports.FormContext = FormContext;
exports.default = useForm;
exports.useFormContext = useFormContext;
